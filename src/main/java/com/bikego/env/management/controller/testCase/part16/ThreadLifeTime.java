package com.bikego.env.management.controller.testCase.part16;

import org.junit.Test;

import java.util.concurrent.locks.ReentrantLock;

public class ThreadLifeTime {

    /**
     * 线程的生命周期
     * 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，
     * 它要经过新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态。
     * 尤其是当线程启动以后，它不可能一直“霸占” 着CPU独自运行，所以CPU需要在多条线程之间切换，
     * 于是线程状态也会多次在运行、就绪之间切换。
     *
     * 注意：
     * 启动线程使用start()方法，而不是run()方法！永远不要调用线程对象的run()方法！调用start()方法来启动线程，
     * 系统会把该run()方法当成线程执行体来处理；但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，
     * 而且在run()方法返回之前其他线程无法并发执行——也就是说，如果直接调用线程对象的run()方法，系统把线程对象当成一个普通对象，
     * 而run()方法也是一个普通方法，而不是线程执行体。
     *
     * 注意：
     * 当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受主线程的影响。
     */


    /**
     * 新建（New）
     * 当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。
     * 此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。
     *
     * 就绪（Ready）
     * 当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程 并没有开始运行，
     * 只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。
     *
     * 运行（Running）
     * 如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态。
     * 当然，在一个多处理器的机器上，将会有多个线程并行（注意是并行：parallel）执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。
     *
     * 阻塞（Blocked）
     * 当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了），线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，
     * 线程调度的细节取决于底 层平台所采用的策略。当发生如下情况时，线程将会进入阻塞状态。
     * ➢ 线程调用sleep()方法主动放弃所占用的处理器资源。
     * ➢ 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。
     * ➢ 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。关于同步监视器的知识、后面将有更深入的介绍。
     * ➢ 线程在等待某个通知（notify）。
     * ➢ 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。
     * 当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。
     * 也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。
     *
     * 当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态。
     * ➢ 调用sleep()方法的线程经过了指定时间。
     * ➢ 线程调用的阻塞式IO方法已经返回。
     * ➢ 线程成功地获得了试图取得的同步监视器。
     * ➢ 线程正在等待某个通知时，其他线程发出了一个通知。
     * ➢ 处于挂起状态的线程被调用了resume()恢复方法。
     *
     * 死亡（Dead）
     * 线程会以如下三种方式结束，结束后就处于死亡状态。
     * ➢ run()或call()方法执行完成，线程正常结束。
     * ➢ 线程抛出一个未捕获的Exception或Error。
     * ➢ 直接调用该线程的stop()方法来结束该线程 —— 该方法容易导致死锁，通常不推荐使用。
     *
     * 为了测试某个线程是否已经死亡，可以调用线程对象的isAlive()方法，
     * 当线程处于就绪、运行、阻塞三种状态时，该方法将返回true；当线程处于新建、死亡两种状态时，该方法将返回false。
     */


    /**
     * join线程
     *
     * Thread提供了让一个线程等待另一个线程完成的方法——join()方法。当在某个程序执行流中调用其他线程的join()方法时，
     * 调用线程将被阻塞，直到被join()方法加入的join线程执行完为止。
     */

    /**
     * 后台线程 (守护线程)
     * 有一种线程，它是在后台运行的，它的任务是为其他的线程提供服务，这种线程被称为“后台线程（Daemon Thread）”，又称为“守护线程”或“精灵线程”。
     * JVM的垃圾回收线程就是典型的后台线程。后台线程有个特征：如果所有的前台线程都死亡，后台线程会自动死亡。
     * 调用Thread对象的setDaemon(true)方法可将指定线程设置成后台线程。
     */

    /**
     * 线程睡眠：sleep 如果需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread类的静态sleep()方法来实现。sleep()方法有两种重载形式。
     * ➢ static void sleep(long millis)：让当前正在执行的线程暂 停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度与准确度的影响。
     * ➢ static void sleep(long millis, int nanos)：让当前正在执行的线程暂停millis毫秒加nanos毫微秒，并进入阻塞状态，
     * 该方法受到系统计时器和线程调度器的精度与准确度的影响。与前面类似的是，程序很少调用第二种形式的sleep()方法。
     */

    /**
     * 线程暂停,让出CPU
     * Thread还提供了一个与sleep()方法有点相似的yield()静态方法，它也可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程转入就绪状态。
     * yield()只是让当前线程暂停一 下，让系统的线程调度器重新调度一次，完全可能的情况是：当某个线程调用了yield()方法暂停之后，线程调度器又将其调度出来重新执行。
     *
     * 关于sleep()方法和yield()方法的区别如下。
     * ➢ sleep()方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级；但yield()方法只会给优先级相同，或优先级更高的线程执行机会。
     * ➢ sleep()方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield()不会将线程转入阻塞状态，它只是强制当前线程进入就绪状态。
     * 因此完全有可能某个线程被yield()方法暂停之后，立即再次获得处理器资源被执行。
     * ➢ sleep()方法声明抛出了InterruptedException异常，所以调 用sleep()方法时要么捕捉该异常，要么显式声明抛出该异常；而yield()方法则没有声明抛出任何异常。
     * ➢ sleep()方法比yield()方法有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。
     */

    /**
     * 线程优先级
     * 每个线程默认的优先级都与创建它的父线程的优先级相同，在默认情况下，main线程具有普通优先级，由main线程创建的子线程也具有普通优先级。
     * Thread 类提供了setPriority（int new Priority）、getPriority()方法来设置和返回指定线程的优先级
     */


    /**
     * 线程同步  当使用多个线程来访问同一个数据时，很容易“偶然”出现线程安全问题。
     *
     * 同步监视器
     * synchronized(obj)
     * {
     *    ...
     * }
     * 上面语法格式中synchronized后括号里的obj就是同步监视器，上面代码的含义是：线程开始执行同步代码块之前，必须先获得对同步监视器的锁定。
     *
     * 注意：
     * 任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对该同步监视器的锁定。
     *
     * “加锁→修改→释放锁”的逻辑，任何线程在修改指定资源之前，首先对该资源加锁，在加锁期间其他线程无法修改该资源，当该线程修改完成后，该线程释放对该资源的锁定。
     * 通过这种方式就可以保证并发线程在任一时刻只有一个线程可以进入修改共享资源的代码区（也被称为临界区），所以同一时刻最多只有一个线程处于临界区内，从而保证了线程的安全性。
     */

    /**
     * 同步方法
     * 同步方法就是使用synchronized关键字来修饰某个方法，则该方法称为同步方法。对于synchronized修饰的实例方法（非static方法）而言，无须显式指定同步监视器，
     * 同步方法的同步监视器是this，也就是调用该方法的对象。
     *
     * 注意：
     * synchronized关键字可以修饰方法，可以修饰代码块，但不能修饰构造器、成员变量等。
     *
     */

    /**
     * 线程会在如下几种情况下释放对同步监视器的锁定。
     * ➢ 当前线程的同步方法、同步代码块执行结束，当前线程即释放同步监视器。
     * ➢ 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行，当前线程将会释放同步监视器。
     * ➢ 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致了该代码块、该方法异常结束时，当前线程将会释放同步监视器。
     * ➢ 当前线程执行同步代码块或同步方法时，程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器。在如下所示的情况下，线程不会释放同步监视器。
     * ➢ 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法来暂停当前线程的执行，当前线程不会释放同步监视器。
     * ➢ 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放同步监视器。当然，程序应该尽量避免使用suspend()和resume()方法来控制线程。
     */

    /**
     * Lock提供了比synchronized方法和synchronized代码块更广泛的锁定操作，Lock允许实现更灵活的结构，可以具有差别很大的属性，并且支持多个相关的Condition对象。
     *
     *
     */

    private final ReentrantLock lock = new ReentrantLock();
    @Test
    public void t0()
    {
        lock.lock();
        try{

            //.....

        }finally{
            lock.unlock();
        }
    }

    /**
     * 死锁及常用处理策略
     * 当两个线程相互等待对方释放同步监视器时就会发生死锁，Java虚拟机没有监测，也没有采取措施来处理死锁情况，所以多线程编程时应该采取措施避免死锁出现。
     * 一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。死锁是很容易发生的，尤其在系统中出现多个同步监视器的情况下
     *
     * ➢ 避免多次锁定：尽量避免同一个线程对多个同步监视器进行锁定。比如上面的死锁程序，主线程要对A、B两个对象（同步监视器）进行锁定，
     * 副线程也要对A、B两个对象进行锁定，这就埋下了导致死锁的隐患。
     * ➢ 具有相同的加锁顺序：如果多个线程需要对多个同步监视器进行锁定，则应该保证它们以相同的顺序请求加锁。比如上面的死锁程序，主线程先对A对象（同步监视器）加锁，
     * 再对B对象（同步监视器）加锁；而副线程则先对B对象加锁，再对A对象加锁。这种方式很容易形成嵌套锁定，进而导致死锁。如果让主线程、副线程按相同的顺序加锁，就可以避免死锁问题。
     * ➢ 使用定时锁：程序调用Lock对象的tryLock()方法加锁时可指定time和unit参数，当超过指定时间后会自动释放对Lock的锁定，这样就可以解开死锁了。
     * ➢ 死锁检测：这是一种依靠算法来实现的死锁预防机制，它主要针对那些不可能实现按序加锁，也不能使用定时锁的场景。
     *
     * 注意：
     * 由于Thread类的suspend()方法也很容易导致死锁，所以Java不再推荐使用该方法来暂停线程的运行。
     */


}
