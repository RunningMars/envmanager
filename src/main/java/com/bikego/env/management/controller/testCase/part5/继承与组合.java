package com.bikego.env.management.controller.testCase.part5;

public class 继承与组合 {
    /**
     * 为了保证父类有良好的封装性，不会被子类随意改变，设计父类通常应该遵循如下规则。
     * ➢ 尽量隐藏父类的内部数据。尽量把父类的所有成员变量都设置成private访问类型，不要让子类直接访问父类的成员变量。
     * ➢ 不要让子类可以随意访问、修改父类的方法。父类中那些仅为辅助其他的工具方法，应该使用private访问控制符修饰，
     * 让子类无法访问该方法；如果父类中的方法需要被外部类调用，则必须以public修饰，但又不希望子类重写该方法，可以使用
     * final修饰符（该修饰符后面会有更详细的介绍）来修饰该方法；如果希望父类的某个方法被子类重写，但不希望被其他类自由访问，则可以使用protected来修饰该方法。
     * ➢ 尽量不要在父类构造器中调用将要被子类重写的方法。
     */

    /**
     * 如果想把某些类设置成最终类，即不能被当成父类，则可以使用final修饰这个类，例如JDK提供的java.lang.String类和
     * java.lang.System类。除此之外，使用private修饰这个类的所有构造器，从而保证子类无法调用该类的构造器，也就无法继承该类。
     * 对于把所有的构造器都使用private修饰的父类而言，可另外提供一个静态方法，用于创建该类的实例。
     */

    /**
     * 到底何时需要从父类派生新的子类呢？不仅需要保证子类是一种特殊的父类，而且需要具备以下两个条件之一。
     * ➢ 子类需要额外增加成员变量，而不仅仅是变量值的改变。例如从Person类派生出Student子类，Person类里没有提供
     * grade（年级）成员变量，而Student类需要grade成员变量来保存Student对象就读的年级，这种父类到子类的派生，就符合Java继承的前提。
     * ➢ 子类需要增加自己独有的行为方式（包括增加新的方法或重写父类的方法）。例如从Person类派生出Teacher类，其中Teacher类需要增加一个teaching()方法，
     * 该方法用于描述Teacher对象独有的行为方式：教学。
     */

    /**
     * 到底该用继承？还是该用组合呢？继承是对已有的类做一番改造，以此获得一个特殊的版本。简而言之，就是将一个较为抽象的类改造成能适用于某些特定需求的类。
     * 因此，对于上面的Wolf和Animal的关系，使用继承更能表达其现实意义。用一个动物来合成一匹狼毫无意义：狼并不是由动物组成的。
     * 反之，如果两个类之间有明确的整体、部分的关系，例如Person类需要复用Arm类的方法（Person对象由Arm对象组合而成），
     * 此时就应该采用组合关系来实现复用，把Arm作 为Person类的组合成员变量，借助于Arm的方法来实现Person的方法，这是一个不错的选择。
     * 总之，继承要表达的是一种“是（is-a）”的关系，而组合表达的是“有（has-a）”的关系。
     */

    /**
     * 初始化块的修饰符只能是static，使用static修饰的初始化块被称为类初始化块（静态初始化块），
     * 没有static修饰的初始化块被称为实例初始化块（非静态初始化块）。初始化块里的代码可以包含任何可执行性语句，
     * 包括定义局部变量、调用其他对象的方法，以及使用分支、循环语句等。
     *
     * 注意： 当Java创建一个对象时，系统先为该对象的所有实例变量分配内存（前提是该类已经被加载过了），
     * 接着程序开始对这些实例变量执行初始化，其初始化顺序是：先执行实例初始化块或声明实例变量时指定的初始值（这两个地方指定初始值的执行顺序与它们在
     * 源代码中的排列顺序相同），再执行构造器里指定的初始值。
     *
     * 如果两个构造器中有相同的初始化代码，且这些初始化代码无须接收参数，就可以把它们放在实例初始化块中定义。通过把多个构造器中的相同代码提取到实例初始化块中定义，
     * 能更好地提高初始化代码的复用，提高整个应用的可维护性。
     *
     * 注意：实际上实例初始化块是一个假象，使用javac命令编译Java类后，该Java类中的实例初始化块会消失—实例初始化块中代码会被
     * “还原”到每个构造器中，且位于构造器所有代码的前面。
     */


    /**
     * 如果定义初始化块时使用了static修饰符，则这个初始化块就变成了类初始化块，也被称为静态初始化块（实例初始化块负责对对象执行初始化，类初始化块则负责对类进行初始化）。
     * 类初始化块是类相关的，系统将在类初始化阶段执行类初始化块，而不是在创建对象时才执行。因此类初始化块总是比实例初始化块先执行。
     * 类初始化块是类相关的，用于对整个类进行初始化处理，通常用于对类变量执行初始化处理。类初始化块不能对实例变量进行初始化处理。
     */

    /**
     * 系统在类初始化阶段执行类初始化块时,不仅会执行本类的类初始化块，而且还会一直上溯到
     * java.lang.Object类（如果它包含类初始化块），先执行java.lang.Object类的类初始化块（如果有），
     * 然后执行其父类的类 初始化块……最后才执行该类的类初始化块，经过这个过程，才完成了该类的初始化过程。
     * 只有当类初始化完成后，才可以在系统中使用 这个类，包括访问这个类的类方法、类变量或者用这个类来创建实例。
     */
}


class Base{
    public Base()
    {
        test();
    }

    protected void t1()
    {
        System.out.println("父类t1");
    }
    public void t2()
    {
        System.out.println("父类t2");
    }
    public void test()
    {
        System.out.println("将被子类重写的方法,父类test");
    }
}

class Sub extends Base{

    private String name;

    public void test()
    {
        System.out.println("子类重写父类的方法,子类test");
        System.out.println("子类name:" + name);

    }

    public static void main(String[] args)
    {
        var s = new Sub();
        s.t1();
    }
}
